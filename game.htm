<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Endless Runner</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #a0d7e6;
            font-family: sans-serif;
            overscroll-behavior: none;
            touch-action: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        canvas {
            display: block;
        }

        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2em;
            transition: opacity 0.5s ease-out;
            opacity: 1;
            pointer-events: auto;
            z-index: 1000;
        }
        #loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #ui-container {
            position: fixed;
            top: 5vh;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            text-shadow: 0 0 5px black;
            z-index: 50;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            padding: 10px 20px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            font-weight: bold;
        }
        #user-name {
            position: fixed;
            top: 5vh;
            right: 5vw;
            color: white;
            text-shadow: 0 0 5px black;
            z-index: 50;
            display: flex;
            align-items: center;
            padding: 10px 20px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            font-weight: bold;
        }
        #score, #speedometer {
            font-size: 1.2em;
            text-align: center;
            width: 100%;
        }

        #game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff4444;
            font-size: 4em;
            font-weight: bold;
            text-shadow: 4px 4px 8px black;
            display: none;
            z-index: 101;
        }
        
        #restart-button {
            position: fixed;
            bottom: 30%;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 255, 255, 0.7);
            border: 2px solid rgba(0, 0, 0, 0.5);
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 1.5em;
            font-weight: bold;
            cursor: pointer;
            z-index: 102;
            display: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        /* Styles for the new on-screen controls */
        .controls {
            position: fixed;
            bottom: 20px;
            display: flex;
            gap: 10px;
        }

        #left-controls {
            left: 20px;
            flex-direction: row; /* Buttons side-by-side */
        }

        #right-controls {
            right: 20px;
            flex-direction: column; /* Buttons stacked */
        }

        .control-button {
            width: 60px;
            height: 60px;
            font-size: 2em;
            background-color: rgba(255, 255, 255, 0.4);
            border: 2px solid rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            color: white;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            display: flex;
            justify-content: center;
            align-items: center;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="loading-screen">Loading...</div>
    <div id="ui-container">
        <div id="score">Score: 0</div>
        <div id="speedometer">Speed: 0 km/h</div>
    </div>
    <div id="user-name">Kunal</div>
    <div id="game-over">GAME OVER!</div>
    <button id="restart-button">RESTART</button>
    <div id="container"></div>

    <!-- On-screen controls -->
    <div id="left-controls" class="controls">
        <button id="left-button" class="control-button">&#8592;</button>
        <button id="right-button" class="control-button">&#8594;</button>
    </div>
    <div id="right-controls" class="controls">
        <button id="forward-button" class="control-button">&#8593;</button>
        <button id="backward-button" class="control-button">&#8595;</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

        const roadWidth = 10;
        const roadLength = 200;
        const maxSpeed = 0.5;
        const acceleration = 0.005;
        const deceleration = 0.002;
        const brakeDeceleration = 0.01;
        let driveSpeed = 0;
        let currentSpeed = 0;
        const carMoveSpeed = 0.15;
        const kerbWidth = 0.3;
        const buildingSpacing = 25;
        const lightSpacing = 30;
        const numBuildings = Math.floor(roadLength * 2 / buildingSpacing);
        const numLights = Math.floor(roadLength * 2 / lightSpacing);
        const kmhMultiplier = 600;

        let scene, camera, renderer;
        let playerCar, carHalfWidth = 1;
        let carBaseY = 0.51;
        let score = 0;
        let isGameOver = false;

        let moveLeft = false;
        let moveRight = false;
        let moveForward = false;
        let moveBackward = false;
        let isBraking = false;
        
        let loadedEnemyCarModel = null;

        const roadLines = [];
        const buildings = [];
        const streetLights = [];
        const points = [];
        const enemyCars = [];
        const trees = [];
        const flowers = [];
        let ground, road;
        let dirLight;

        const loadingScreen = document.getElementById('loading-screen');
        const scoreElement = document.getElementById('score');
        const speedometerElement = document.getElementById('speedometer');
        const gameOverElement = document.getElementById('game-over');
        const restartButton = document.getElementById('restart-button');
        const container = document.getElementById('container');
        const leftControls = document.getElementById('left-controls');
        const rightControls = document.getElementById('right-controls');
        
        const leftButton = document.getElementById('left-button');
        const rightButton = document.getElementById('right-button');
        const forwardButton = document.getElementById('forward-button');
        const backwardButton = document.getElementById('backward-button');

        const grayMaterial = new THREE.MeshLambertMaterial({ color: 0x555555 });
        const whiteMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
        const greenMaterial = new THREE.MeshLambertMaterial({ color: 0x55aa55 });
        const yellowMaterial = new THREE.MeshLambertMaterial({ color: 0xffff00, emissive: 0xaaaa00 });
        const pointMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, emissive: 0xffaa00 });
        const redMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
        const blueMaterial = new THREE.MeshLambertMaterial({ color: 0x0000ff });
        const poleMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });

        const playerBox = new THREE.Box3();
        const enemyBoxes = new Map();
        const pointBoxes = new Map();

        function createKerbTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            context.fillStyle = '#ff0000';
            context.fillRect(0, 0, 32, 64);
            context.fillStyle = '#ffffff';
            context.fillRect(32, 0, 32, 64);
            const texture = new THREE.CanvasTexture(canvas);
            texture.repeat.set(1, roadLength / 1);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return new THREE.MeshStandardMaterial({ map: texture, metalness: 0, roughness: 1 });
        }
        const kerbMaterial = createKerbTexture();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xa0d7e6);
            scene.fog = new THREE.Fog(0xa0d7e6, roadLength * 0.4, roadLength * 0.9);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, carBaseY + 3, -7);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            container.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
            dirLight.position.set(50, 200, 100);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 500;
            dirLight.shadow.camera.left = -50;
            dirLight.shadow.camera.right = 50;
            dirLight.shadow.camera.top = 50;
            dirLight.shadow.camera.bottom = -50;
            scene.add(dirLight);

            setupEnvironment();
            loadAssets();
            setupControls();
            window.addEventListener('resize', onWindowResize);
            restartButton.addEventListener('click', resetGame);
            restartButton.addEventListener('touchend', resetGame);
        }

        function createGrassTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const context = canvas.getContext('2d');
            const baseColor = '#55aa55';
            context.fillStyle = baseColor;
            context.fillRect(0, 0, 128, 128);

            for (let i = 0; i < 500; i++) {
                const x = Math.random() * 128;
                const y = Math.random() * 128;
                const size = Math.random() * 2;
                context.fillStyle = `rgba(0, 0, 0, ${Math.random() * 0.2 + 0.1})`;
                context.fillRect(x, y, size, size);
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.repeat.set(roadLength * 2, roadLength * 2);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        function setupEnvironment() {
            const grassTexture = createGrassTexture();
            const grassMaterial = new THREE.MeshStandardMaterial({ map: grassTexture, roughness: 0.8 });

            const groundGeo = new THREE.PlaneGeometry(roadLength * 1.5, roadLength * 1.5);
            ground = new THREE.Mesh(groundGeo, grassMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.05;
            ground.receiveShadow = true;
            scene.add(ground);

            const roadGeo = new THREE.PlaneGeometry(roadWidth, roadLength * 2);
            road = new THREE.Mesh(roadGeo, grayMaterial);
            road.rotation.x = -Math.PI / 2;
            road.position.y = 0;
            road.receiveShadow = true;
            scene.add(road);

            const kerbGeo = new THREE.BoxGeometry(kerbWidth, 0.2, roadLength * 2);
            const kerbLeft = new THREE.Mesh(kerbGeo, kerbMaterial);
            kerbLeft.position.set(-roadWidth / 2 - kerbWidth / 2, 0.1, 0);
            kerbLeft.castShadow = true;
            kerbLeft.receiveShadow = true;
            scene.add(kerbLeft);

            const kerbRight = new THREE.Mesh(kerbGeo, kerbMaterial);
            kerbRight.position.set(roadWidth / 2 + kerbWidth / 2, 0.1, 0);
            kerbRight.castShadow = true;
            kerbRight.receiveShadow = true;
            scene.add(kerbRight);

            generateRoadLines();
            generateBuildings(numBuildings);
            generateStreetLights(numLights);
            generatePoints(15);
            generateTreesAndFlowers(50);
        }

        function generateRoadLines() {
            roadLines.forEach(line => scene.remove(line));
            roadLines.length = 0;

            const lineGeo = new THREE.BoxGeometry(0.3, 0.01, 4);
            const gap = 4;
            const totalLines = Math.floor(roadLength * 2 / (4 + gap));
            for (let i = 0; i < totalLines; i++) {
                const line = new THREE.Mesh(lineGeo, whiteMaterial);
                line.position.set(0, 0.01, roadLength - i * (4 + gap));
                line.receiveShadow = true;
                roadLines.push(line);
                scene.add(line);
            }
        }

        function generateBuildings(count) {
            buildings.forEach(building => scene.remove(building));
            buildings.length = 0;

            for (let i = 0; i < count; i++) {
                const zPos = -roadLength + (i / count) * roadLength * 2;
                for (let side = -1; side <= 1; side += 2) {
                    const width = Math.random() * 8 + 4;
                    const height = Math.random() * 30 + 10;
                    const depth = Math.random() * 8 + 4;
                    const geometry = new THREE.BoxGeometry(width, height, depth);
                    const material = new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff });
                    const building = new THREE.Mesh(geometry, material);
                    building.position.set(side * (roadWidth / 2 + kerbWidth + width / 2 + Math.random() * 10), height / 2, zPos);
                    building.castShadow = true;
                    building.receiveShadow = true;
                    buildings.push(building);
                    scene.add(building);
                }
            }
        }

        function generateStreetLights(count) {
            streetLights.forEach(light => scene.remove(light));
            streetLights.length = 0;

            const poleGeo = new THREE.CylinderGeometry(0.1, 0.1, 6, 8);
            const armGeo = new THREE.BoxGeometry(1, 0.1, 0.1);
            const lightSphereGeo = new THREE.SphereGeometry(0.2, 16, 16);

            for (let i = 0; i < count; i++) {
                const zPos = -roadLength + (i / count) * roadLength * 2;
                for (let side = -1; side <= 1; side += 2) {
                    const pole = new THREE.Mesh(poleGeo, poleMaterial);
                    pole.position.set(side * (roadWidth / 2 + kerbWidth + 0.5), 3, zPos);
                    pole.castShadow = true;
                    pole.receiveShadow = true;
                    scene.add(pole);
                    streetLights.push(pole);

                    const arm = new THREE.Mesh(armGeo, poleMaterial);
                    arm.position.set(side * (roadWidth / 2 + kerbWidth + 1), 5.9, zPos);
                    arm.rotation.y = side === 1 ? -Math.PI / 2 : Math.PI / 2;
                    arm.castShadow = true;
                    arm.receiveShadow = true;
                    scene.add(arm);
                    streetLights.push(arm);

                    const lightSphere = new THREE.Mesh(lightSphereGeo, yellowMaterial);
                    lightSphere.position.set(side * (roadWidth / 2 + kerbWidth + 1.5), 5.9, zPos);
                    scene.add(lightSphere);
                    streetLights.push(lightSphere);

                    const pointLight = new THREE.PointLight(0xffffa0, 1, 15);
                    pointLight.position.copy(lightSphere.position);
                    scene.add(pointLight);
                    streetLights.push(pointLight);
                }
            }
        }

        function generatePoints(count) {
            points.forEach(point => scene.remove(point));
            points.length = 0;
            pointBoxes.clear();

            const pointGeo = new THREE.SphereGeometry(0.3, 16, 16);
            for (let i = 0; i < count; i++) {
                const point = new THREE.Mesh(pointGeo, pointMaterial);
                point.position.set(
                    (Math.random() - 0.5) * (roadWidth - 1),
                    0.4,
                    (Math.random() - 0.5) * roadLength
                );
                point.userData.active = true;
                points.push(point);
                pointBoxes.set(point, new THREE.Box3().setFromObject(point));
                scene.add(point);
            }
        }

        function generateTraffic(count) {
            enemyCars.forEach(car => scene.remove(car));
            enemyCars.length = 0;
            enemyBoxes.clear();

            if (!loadedEnemyCarModel) {
                console.error("No enemy car model loaded. Cannot generate traffic.");
                return;
            }

            const laneOffset = roadWidth / 4;
            for (let i = 0; i < count; i++) {
                const enemyCar = loadedEnemyCarModel.clone();
                
                // Assign a new random color to each enemy car
                const randomColor = new THREE.Color(Math.random(), Math.random(), Math.random());
                enemyCar.traverse((node) => {
                    if (node.isMesh && node.material) {
                        node.material = node.material.clone();
                        node.material.color = randomColor;
                    }
                    node.castShadow = true;
                    node.receiveShadow = true;
                });

                const initialX = Math.random() > 0.5 ? laneOffset : -laneOffset;
                enemyCar.position.set(initialX, carBaseY, roadLength * 0.7 + i * (roadLength / count));
                
                enemyCars.push(enemyCar);
                enemyBoxes.set(enemyCar, new THREE.Box3().setFromObject(enemyCar));
                scene.add(enemyCar);
            }
        }

        function generateTreesAndFlowers(count) {
            trees.forEach(tree => scene.remove(tree));
            trees.length = 0;
            flowers.forEach(flower => scene.remove(flower));
            flowers.length = 0;

            const trunkGeo = new THREE.CylinderGeometry(0.5, 0.5, 4, 8);
            const leavesGeo = new THREE.ConeGeometry(2, 6, 8);
            const trunkMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const leavesMat = new THREE.MeshLambertMaterial({ color: 0x228B22 });

            const flowerMat = new THREE.MeshLambertMaterial({ color: 0xff00ff });
            const flowerGeo = new THREE.SphereGeometry(0.2, 8, 8);
            const flowerStemGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.5, 4);

            for (let i = 0; i < count; i++) {
                const zPos = (Math.random() - 0.5) * roadLength * 2;
                const side = Math.random() > 0.5 ? 1 : -1;
                const xPos = side * (roadWidth / 2 + kerbWidth + 3 + Math.random() * 10);
                
                // Tree
                const treeGroup = new THREE.Group();
                const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                trunk.position.y = 2;
                const leaves = new THREE.Mesh(leavesGeo, leavesMat);
                leaves.position.y = 5;
                treeGroup.add(trunk, leaves);
                treeGroup.position.set(xPos, 0, zPos);
                treeGroup.castShadow = true;
                treeGroup.receiveShadow = true;
                trees.push(treeGroup);
                scene.add(treeGroup);

                // Flowers
                const numFlowers = Math.floor(Math.random() * 5) + 1;
                for(let j = 0; j < numFlowers; j++) {
                    const flowerStem = new THREE.Mesh(flowerStemGeo, new THREE.MeshLambertMaterial({ color: 0x008000 }));
                    const flowerHead = new THREE.Mesh(flowerGeo, new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff }));
                    flowerStem.position.set(xPos + (Math.random() - 0.5) * 2, 0.25, zPos + (Math.random() - 0.5) * 2);
                    flowerHead.position.set(flowerStem.position.x, flowerStem.position.y + 0.25, flowerStem.position.z);
                    flowers.push(flowerStem, flowerHead);
                    scene.add(flowerStem, flowerHead);
                }
            }
        }

        function loadAssets() {
            const loadingManager = new THREE.LoadingManager();

            loadingManager.onProgress = (url, loaded, total) => {
                const progress = Math.round((loaded / total) * 100);
                loadingScreen.innerHTML = `Loading ${progress}%...`;
            };

            loadingManager.onLoad = () => {
                setTimeout(() => {
                    loadingScreen.classList.add('hidden');
                    generateTraffic(8);
                    animate();
                }, 500);
            };

            const dracoLoader = new DRACOLoader(loadingManager);
            dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.7/');

            const loader = new GLTFLoader(loadingManager);
            loader.setDRACOLoader(dracoLoader);

            const carModelUrl = 'https://threejs.org/examples/models/gltf/ferrari.glb';

            // Load player car
            loader.load(
                carModelUrl,
                (gltf) => {
                    playerCar = gltf.scene;
                    playerCar.scale.set(0.8, 0.8, 0.8);
                    playerCar.rotation.y = Math.PI;

                    const box = new THREE.Box3().setFromObject(playerCar);
                    const size = new THREE.Vector3();
                    box.getSize(size);
                    carHalfWidth = size.x / 2 * 0.8;
                    carBaseY = -box.min.y * 0.8;
                    playerCar.position.set(0, carBaseY, 0);

                    playerCar.traverse((node) => {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                        }
                    });
                    scene.add(playerCar);

                    camera.position.set(0, carBaseY + 3, -7);
                    camera.lookAt(playerCar.position.x, carBaseY + 1, playerCar.position.z + 5);
                },
                undefined,
                (error) => {
                    console.error("Failed to load player car model:", error);
                    loadingScreen.innerHTML = 'Error loading player car model.';
                }
            );

            // Load enemy car model
            loader.load(
                carModelUrl,
                (gltf) => {
                    loadedEnemyCarModel = gltf.scene;
                    loadedEnemyCarModel.scale.set(0.8, 0.8, 0.8);
                    loadedEnemyCarModel.rotation.y = Math.PI;
                    loadedEnemyCarModel.traverse((node) => {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                        }
                    });
                },
                undefined,
                (error) => {
                    console.error("Failed to load enemy car model:", error);
                }
            );
        }

        function setupControls() {
            // Keyboard controls
            document.addEventListener('keydown', (event) => {
                switch (event.key) {
                    case 'ArrowLeft':
                    case 'a':
                        moveLeft = true;
                        moveRight = false;
                        break;
                    case 'ArrowRight':
                    case 'd':
                        moveRight = true;
                        moveLeft = false;
                        break;
                    case 'ArrowUp':
                    case 'w':
                        moveForward = true;
                        break;
                    case 'ArrowDown':
                    case 's':
                        moveBackward = true;
                        break;
                    case ' ':
                        isBraking = true;
                        break;
                }
            });

            document.addEventListener('keyup', (event) => {
                switch (event.key) {
                    case 'ArrowLeft':
                    case 'a':
                        moveLeft = false;
                        break;
                    case 'ArrowRight':
                    case 'd':
                        moveRight = false;
                        break;
                    case 'ArrowUp':
                    case 'w':
                        moveForward = false;
                        break;
                    case 'ArrowDown':
                    case 's':
                        moveBackward = false;
                        break;
                    case ' ':
                        isBraking = false;
                        break;
                }
            });

            // On-screen button controls
            leftButton.addEventListener('mousedown', () => moveLeft = true);
            leftButton.addEventListener('touchstart', (e) => { e.preventDefault(); moveLeft = true; });
            leftButton.addEventListener('mouseup', () => moveLeft = false);
            leftButton.addEventListener('touchend', () => moveLeft = false);

            rightButton.addEventListener('mousedown', () => moveRight = true);
            rightButton.addEventListener('touchstart', (e) => { e.preventDefault(); moveRight = true; });
            rightButton.addEventListener('mouseup', () => moveRight = false);
            rightButton.addEventListener('touchend', () => moveRight = false);

            forwardButton.addEventListener('mousedown', () => moveForward = true);
            forwardButton.addEventListener('touchstart', (e) => { e.preventDefault(); moveForward = true; });
            forwardButton.addEventListener('mouseup', () => moveForward = false);
            forwardButton.addEventListener('touchend', () => moveForward = false);

            backwardButton.addEventListener('mousedown', () => moveBackward = true);
            backwardButton.addEventListener('touchstart', (e) => { e.preventDefault(); moveBackward = true; });
            backwardButton.addEventListener('mouseup', () => moveBackward = false);
            backwardButton.addEventListener('touchend', () => moveBackward = false);
        }

        function recycleObjects() {
            const resetZ = roadLength;

            roadLines.forEach(line => {
                if (line.position.z < -roadLength / 2) line.position.z += roadLength;
            });

            buildings.forEach(building => {
                if (building.position.z < -roadLength) {
                    building.position.z += roadLength * 2;
                    building.scale.set(1, 1, 1);
                    const width = Math.random() * 8 + 4;
                    const height = Math.random() * 30 + 10;
                    const depth = Math.random() * 8 + 4;
                    building.geometry.dispose();
                    building.geometry = new THREE.BoxGeometry(width, height, depth);
                    building.position.y = height / 2;
                    building.position.x = (building.position.x > 0 ? 1 : -1) * (roadWidth / 2 + kerbWidth + width / 2 + Math.random() * 10);
                }
            });

            streetLights.forEach(light => {
                if (light.position.z < -roadLength) light.position.z += roadLength * 2;
            });
            
            points.forEach(point => {
                if (point.position.z < -roadLength || !point.userData.active) {
                    point.userData.active = true;
                    point.position.set(
                        (Math.random() - 0.5) * (roadWidth - 1),
                        0.4,
                        resetZ + Math.random() * roadLength / 2
                    );
                    point.visible = true;
                    pointBoxes.get(point).setFromObject(point);
                }
            });

            enemyCars.forEach(car => {
                if (car.position.z < -roadLength / 2) {
                    const laneOffset = roadWidth / 4;
                    const newX = Math.random() > 0.5 ? laneOffset : -laneOffset;
                    car.position.set(newX, carBaseY, resetZ + Math.random() * roadLength * 0.5);
                }
            });

            trees.forEach(tree => {
                if (tree.position.z < -roadLength) tree.position.z += roadLength * 2;
            });

            flowers.forEach(flower => {
                if (flower.position.z < -roadLength) flower.position.z += roadLength * 2;
            });
        }

        function checkCollisions() {
            if (!playerCar) return;

            playerBox.setFromObject(playerCar);

            for (const car of enemyCars) {
                const box = enemyBoxes.get(car);
                if (box) box.setFromObject(car);
                if (playerBox.intersectsBox(box)) {
                    isGameOver = true;
                    gameOverElement.style.display = 'block';
                    restartButton.style.display = 'block';
                    leftControls.style.display = 'none';
                    rightControls.style.display = 'none';
                    return;
                }
            }

            for (const point of points) {
                if (point.userData.active) {
                    pointBoxes.get(point).setFromObject(point);
                    const box = pointBoxes.get(point);
                    if (box && playerBox.intersectsBox(box)) {
                        point.userData.active = false;
                        point.visible = false;
                        score += 10;
                        scoreElement.innerText = `Score: ${score}`;
                    }
                }
            }
        }

        function resetGame() {
            isGameOver = false;
            score = 0;
            currentSpeed = 0;
            driveSpeed = 0;

            scoreElement.innerText = `Score: 0`;
            gameOverElement.style.display = 'none';
            restartButton.style.display = 'none';
            leftControls.style.display = 'flex';
            rightControls.style.display = 'flex';
            
            playerCar.position.set(0, carBaseY, 0);

            generateRoadLines();
            generateBuildings(numBuildings);
            generateStreetLights(numLights);
            generatePoints(15);
            generateTraffic(8);
            generateTreesAndFlowers(50);

            animate();
        }

        function animate() {
            if (isGameOver || !playerCar) return;
            requestAnimationFrame(animate);

            if (moveForward) {
                currentSpeed = Math.min(maxSpeed, currentSpeed + acceleration);
            } else if (moveBackward) {
                currentSpeed = Math.max(-maxSpeed * 0.5, currentSpeed - deceleration);
            } else if (isBraking) {
                currentSpeed = Math.max(0, currentSpeed - brakeDeceleration);
            } else {
                currentSpeed = Math.max(0, currentSpeed - deceleration);
            }
            driveSpeed = currentSpeed;
            
            roadLines.forEach(obj => { if(obj) obj.position.z -= driveSpeed; });
            buildings.forEach(obj => { if(obj) obj.position.z -= driveSpeed; });
            streetLights.forEach(obj => { if(obj) obj.position.z -= driveSpeed; });
            points.forEach(obj => { if(obj) obj.position.z -= driveSpeed; });
            enemyCars.forEach(obj => { if(obj) obj.position.z -= driveSpeed; });
            trees.forEach(obj => { if(obj) obj.position.z -= driveSpeed; });
            flowers.forEach(obj => { if(obj) obj.position.z -= driveSpeed; });

            let targetX = playerCar.position.x;
            if (moveLeft) {
                targetX -= carMoveSpeed;
            } else if (moveRight) {
                targetX += carMoveSpeed;
            }

            const roadBound = roadWidth / 2 - kerbWidth - carHalfWidth;
            playerCar.position.x = Math.max(-roadBound, Math.min(roadBound, targetX));

            recycleObjects();
            checkCollisions();

            camera.position.x += (playerCar.position.x - camera.position.x) * 0.1;
            camera.lookAt(playerCar.position.x, carBaseY + 1, playerCar.position.z + 5);

            renderer.render(scene, camera);
            
            speedometerElement.innerText = `Speed: ${Math.round(currentSpeed * kmhMultiplier)} km/h`;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>
